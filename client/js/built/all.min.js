/* dom99.js */
 /*        Copyright Cyril Walle 2018.
Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE.txt or copy at
         http://www.boost.org/LICENSE_1_0.txt) */
/*
    document ELEMENT_PROPERTY, LIST_ITEM_PROPERTY, CONTEXT element extension,
    use WeakMap instead where supported

    decide when to use event
        .target
        .orignialTarget
        .currentTarget

    when to use is="" syntax and when to use <x-element></x-element> ?
    think about overlying framework

    add data-list-strategy to allow opt in declarative optimization
        same length, different content
        same content, different length
        key based identification
    data-function-context to allow context less

    transform recursive into sequential flow

    add data-scoped for data-function to allow them to be
    scoped inside an element with data-inside ?

    addEventListener(`x`, y, {passive: true}); ? explore
*/
/*jslint
    es6, maxerr: 200, browser, devel, fudge, maxlen: 100, node, for
*/
const d$1 = (function () {
    const NAME = `DOM99`;
    const ELEMENT_NODE = 1; // document.body.ELEMENT_NODE === 1
    const CONTEXT = `${NAME}_C`;
    const LIST_ITEM_PROPERTY = `${NAME}_L`;
    const ELEMENT_PROPERTY = `${NAME}_E`;
    const ELEMENT_LIST_ITEM = `${NAME}_I`;
    const CUSTOM_ELEMENT = `${NAME}_X`;
    const LIST_CHILDREN = `${NAME}_R`;
    const INSIDE_SYMBOL = `>`;

    //root collections
    const variableSubscribers = {};
    const listSubscribers = {};
    const variables = {};
    const elements = {};
    const templateFromName = {};
    const functions = {};

    let pathIn = [];

    let directivePairs;

    // recursive or have tri+-dependent graph
    let feed;
    let elementsDeepForEach;
    let activate;
    let activateCloneTemplate;

    const hasOwnProperty = Object.prototype.hasOwnProperty;

    const freezeLiveCollection = function (liveCollection) {
      /* freezes HTMLCollection or Node.childNodes*/
        const length = liveCollection.length;
        const frozenArray = [];
        let i;
        for (i = 0; i < length; i += 1) {
            frozenArray.push(liveCollection[i]);
        }
        return frozenArray;
    };

    const isObjectOrArray = function (x) {
        /*array or object*/
        return (typeof x === `object` && x !== null);
    };

    const copyArrayFlat = function (array) {
        return array.slice();
    };

    const pushOrCreateArrayAt = function (object, key, valueToPush) {
      // don't need to use hasOwnProp as there is no array in the prototype
      // but still use it to avoid a warning
      // const potentialArray = object[key]
        if (hasOwnProperty.call(object, key)) {
            // eventually the if is always true
            object[key].push(valueToPush);
        } else {
            // only for the first time
            object[key] = [valueToPush];
        }
    };

    const MISS = `MISS`;
    const valueElseMissDecorator = function (object) {
        /*Decorator function around an Object to provide a default value
        Decorated object must have a MISS key with the default value associated
        Arrays are also objects
        */
        return function (key) {
            if (hasOwnProperty.call(object, key)) {
                return object[key];
            }
            return object[MISS];
        };
    };

    const propertyFromTag = valueElseMissDecorator({
        //Input Type : appropriate property name to retrieve and set the value
        [`INPUT`]: `value`,
        [`TEXTAREA`]: `value`,
        [`PROGRESS`]: `value`,
        [`SELECT`]: `value`,
        [`IMG`]: `src`,
        [`SOURCE`]: `src`,
        [`AUDIO`]: `src`,
        [`VIDEO`]: `src`,
        [`TRACK`]: `src`,
        [`SCRIPT`]: `src`,
        [`OPTION`]: `value`,
        [`LINK`]: `href`,
        [`DETAILS`]: `open`,
        MISS: `textContent`
    });

    const propertyFromInputType = valueElseMissDecorator({
        //Input Type : appropriate property name to retrieve and set the value
        [`checkbox`]: `checked`,
        [`radio`]: `checked`,
        MISS: `value`
    });

    const inputEventFromType = valueElseMissDecorator({
        [`checkbox`]: `change`,
        [`radio`]: `change`,
        [`range`]: `change`,
        [`file`]: `change`,
        MISS: `input`
    });

    const eventFromTag = valueElseMissDecorator({
        [`SELECT`]: `change`,
        [`TEXTAREA`]: `input`,
        [`BUTTON`]: `click`,
        MISS: `click`
    });

    const options = {
        doneSymbol: `*`,
        tokenSeparator: `-`,
        listSeparator: ` `,
        directives: {
            function: `data-function`,
            variable: `data-variable`,
            element: `data-element`,
            list: `data-list`,
            inside: `data-inside`,
            template: `data-template`
        },

        propertyFromElement: function (element) {
            // defines what is changing when data-variable is changing
            // for <p> it is textContent
            let tagName;
            if (element.tagName !== undefined) {
                tagName = element.tagName;
            } else {
                tagName = element;
            }
            if (tagName === `INPUT`) {
                return propertyFromInputType(element.type);
            }
            return propertyFromTag(tagName);
        },

        eventNameFromElement: function (element) {
            // defines the default event for an element
            // i.e. when data-function is omitting the event
            const tagName = element.tagName;
            if (tagName === `INPUT`) {
                return inputEventFromType(element.type);
            }
            return eventFromTag(tagName);
        },

        tagNamesForUserInput: [
            `INPUT`,
            `TEXTAREA`,
            `SELECT`,
            `DETAILS`
        ]
    };

    const createElement2 = function (elementDescription) {
        /*element.setAttribute(attr, value) is good to set
        initial attribute like when html is first loaded
        setAttribute won't change some live things like .value for input,
        for instance, setAttribute is the correct choice for creation
        element.attr = value is good to change the live values
        always follow these words to avoid rare bugs*/
        const element = document.createElement(elementDescription.tagName);
        Object.entries(elementDescription).forEach(function ([key, value]) {
            if (key !== `tagName`) {
                element.setAttribute(key, value);
            }
        });
        return element;
    };

    // alternative not used yet
    // const createElement2 = function ({tagName, ...elementDescription}) {
        // const element = document.createElement(tagName);
        // Object.entries(elementDescription).forEach(function ([key, value]) {
            // element.setAttribute(key, value);
        // });
        // return element;
    // };

    elementsDeepForEach = function (startElement, callBack) {
        callBack(startElement);
        // https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/firstElementChild
        // is not supported in Edge/Safari on DocumentFragments
        // let element = startElement.firstElementChild;
        // this does not produce an error, but simply returns undefined
        let node = startElement.firstChild;
        while (node) {
            if (node.nodeType === ELEMENT_NODE) {
                elementsDeepForEach(node, callBack);
                node = node.nextElementSibling;
            } else {
                node = node.nextSibling;
            }
        }

    };

    const customElementNameFromElement = function (element) {
        return element.getAttribute(`is`) || element.tagName.toLowerCase();
    };

    const addEventListener = function (element, eventName, callBack, useCapture = false) {
        element.addEventListener(eventName, callBack, useCapture);
    };

    const cloneTemplate = function (template) {
        if (!template) {
            console.error(
                `Template missing <template ${options.directives.template}="d-name">
                    Template Content
                </template>`
            );
        }
        return document.importNode(template.content, true);
    };

    const contextFromEvent = function (event, parent) {
        if (event || parent) {
            let element;
            if (event && event.target) {
                element = event.target;
            } else {
                element = parent;
            }

            if (hasOwnProperty.call(element, CONTEXT)) {
                return element[CONTEXT];
            } else {
                if (element.parentNode) {
                    return contextFromEvent(undefined, element.parentNode);
                } else {
                    
                }
            }
        }
        console.warn(
            event,
            `has no context. contextFromEvent for top level elements is not needed.`
        );
        return ``;
    };

    const contextFromArray = function (pathIn) {
        return pathIn.join(INSIDE_SYMBOL);
    };

    const enterObject = function (key) {
        pathIn.push(key);
    };

    const leaveObject = function () {
        pathIn.pop();
    };

    const getParentContext = function (context) {
        const split = context.split(INSIDE_SYMBOL);
        split.pop();
        return split.join(INSIDE_SYMBOL);
    };

    const contextFromArrayWith = function (pathIn, withWhat) {
        if (pathIn.length === 0) {
            return withWhat;
        }
        return `${contextFromArray(pathIn)}${INSIDE_SYMBOL}${withWhat}`;
    };

    const normalizeStartPath = function (startPath) {
        // this is because `a>b>c` is irregular
        // `a>b>c>` or `>a>b>c` would not need such normalization
        if (startPath) {
            return `${startPath}${INSIDE_SYMBOL}`;
        }
        return startPath;
    };

    const deleteAllStartsWith = function (object, prefix) {
        Object.keys(object).forEach(function (key) {
            if (key.startsWith(prefix)) {
                delete object[key];
            }
        });
    };

    const forgetContext = function (path) {
        /*Removing a DOM element with .remove() or .innerHTML = `` will NOT delete
        all the element references if you used the underlying nodes in dom99
        A removed element will continue receive invisible automatic updates
        it also takes space in the memory.

        And all of this doesn't matter for 1-100 elements

        */
        deleteAllStartsWith(variableSubscribers, path);
        deleteAllStartsWith(listSubscribers, path);
        deleteAllStartsWith(variables, path);
        deleteAllStartsWith(elements, path);
    };

    const notifyOneVariableSubscriber = function (variableSubscriber, value) {
        variableSubscriber[variableSubscriber[ELEMENT_PROPERTY]] = value;
    };

    const notifyVariableSubscribers = function (subscribers, value) {
        if (value === undefined) {
            // undefined can be used to use the default value
            // without explicit if else
            return;
        }
        subscribers.forEach(function (variableSubscriber) {
            notifyOneVariableSubscriber(variableSubscriber, value);
        });
    };

    const removeNode = function (node) {
        node.remove();
    };

    const notifyOneListSubscriber = function (listContainer, startPath, data) {
        const fragment = document.createDocumentFragment();
        if (
            hasOwnProperty.call(listContainer, CUSTOM_ELEMENT) &&
            hasOwnProperty.call(templateFromName, listContainer[CUSTOM_ELEMENT])
        ) {
            // composing with custom element
            const template = templateFromName[listContainer[CUSTOM_ELEMENT]];
            const previous = copyArrayFlat(pathIn);
            pathIn = startPath.split(INSIDE_SYMBOL);
            const normalizedPath = normalizeStartPath(startPath);
            const newLength = data.length;
            let oldLength;
            let pathInside;
            if (hasOwnProperty.call(listContainer, LIST_CHILDREN)) {
                // remove nodes and variable subscribers that are not used
                oldLength = listContainer[LIST_CHILDREN].length;
                if (oldLength > newLength) {
                    let i;
                    for (i = newLength; i < oldLength; i += 1) {
                        pathInside = `${normalizedPath}${i}`;
                        listContainer[LIST_CHILDREN][i].forEach(removeNode);
                        forgetContext(pathInside);
                    }
                    listContainer[LIST_CHILDREN].length = newLength;
                }
            } else {
                listContainer[LIST_CHILDREN] = [];
                oldLength = 0;
            }

            data.forEach(function (dataInside, i) {
                pathInside = `${normalizedPath}${i}`;
                feed(pathInside, dataInside);
                if (i >= oldLength) {
                    // cannot remove document fragment after insert because they empty themselves
                    // have to freeze the children to still have a reference
                    const activatedClone = activateCloneTemplate(
                        template,
                        String(i)
                    );
                    listContainer[LIST_CHILDREN].push(
                        freezeLiveCollection(activatedClone.childNodes)
                    );
                    fragment.appendChild(activatedClone);
                }
                // else reusing, feed updated with new data the old nodes
            });
            pathIn = previous;
        } else {
            listContainer.innerHTML = ``;
            data.forEach(function (value) {
                const listItem = document.createElement(listContainer[ELEMENT_LIST_ITEM]);
                if (isObjectOrArray(value)) {
                    Object.assign(listItem, value);
                } else {
                    listItem[listContainer[LIST_ITEM_PROPERTY]] = value;
                }
                fragment.appendChild(listItem);
            });
        }
        listContainer.appendChild(fragment);
    };

    const notifyListSubscribers = function (subscribers, startPath, data) {
        subscribers.forEach(function (listContainer) {
            notifyOneListSubscriber(listContainer, startPath, data);
        });
    };

    feed = function (startPath, data) {
        if (data === undefined) {
            data = startPath;
            startPath = ``;
        }
        if (isObjectOrArray(startPath)) {
            console.error(
                `Incorrect types passed to d.feed,
                d.feed(string, object) or d.feed(object)`
            );
        }
        if (!isObjectOrArray(data)) {
            variables[startPath] = data;
            if (hasOwnProperty.call(variableSubscribers, startPath)) {
                notifyVariableSubscribers(variableSubscribers[startPath], data);
            }
        } else if (Array.isArray(data)) {
            variables[startPath] = data;
            if (hasOwnProperty.call(listSubscribers, startPath)) {
                notifyListSubscribers(listSubscribers[startPath], startPath, data);
            }
        } else {
            const normalizedPath = normalizeStartPath(startPath);
            Object.entries(data).forEach(function ([key, value]) {
                const path = `${normalizedPath}${key}`;
                feed(path, value);
            });
        }
    };

    /*not used
    alternative use the new third argument options, once
    const onceAddEventListener = function (element, eventName, callBack, useCapture=false) {
        let tempFunction = function (event) {
            //called once only
            callBack(event);
            element.removeEventListener(eventName, tempFunction, useCapture);
        };
        addEventListener(element, eventName, tempFunction, useCapture);
    };*/

    const applyFunctionOriginal = function (element, eventName, functionName) {
        if (!functions[functionName]) {
            console.error(`Event listener ${functionName} not found.`);
        }
        addEventListener(element, eventName, functions[functionName]);
        // todo only add context when not top level ? (inside sommething)
        element[CONTEXT] = contextFromArray(pathIn);
    };

    const pluggedFunctions = [];
    let applyFunction = applyFunctionOriginal;

    const applyFunctions = function (element, attributeValue) {
        attributeValue.split(options.listSeparator).forEach(
            function (attributeValueSplit) {
                const tokens = attributeValueSplit.split(options.tokenSeparator);
                let functionName;
                let eventName;
                if (tokens.length === 1) {
                    functionName = tokens[0];
                    eventName = options.eventNameFromElement(element);
                } else {
                    [eventName, functionName] = tokens;
                }
                applyFunction(element, eventName, functionName);
            }
        );
    };

    const applylist = function (element, attributeValue) {
        /* js array --> DOM list
        <ul data-list="var-li"></ul>

            */
        const [
            variableName,
            listItemTagName,
            optional
        ] = attributeValue.split(options.tokenSeparator);

        let fullName = `-`;

        if (!variableName) {
            console.error(
                element,
                `Use ${options.directives.list}="variableName-tagName" format!`
            );
        }

        if (optional) {
            // for custom elements
            fullName = `${listItemTagName}-${optional}`;
            element[CUSTOM_ELEMENT] = fullName;
        } else {
            element[LIST_ITEM_PROPERTY] = options.propertyFromElement(
                listItemTagName.toUpperCase()
            );
            element[ELEMENT_LIST_ITEM] = listItemTagName;
        }

        // could send path as array directly
        // but have to change notifyOneListSubscriber to take in path as Array or String
        // before
        const path = contextFromArrayWith(pathIn, variableName);

        pushOrCreateArrayAt(listSubscribers, path, element);

        if (hasOwnProperty.call(variables, path)) {
            notifyOneListSubscriber(element, path, variables[path]);
        }
    };

    const applyVariable = function (element, variableName) {
        /* two-way bind
        example : called for <input data-variable="a">
        in this example the variableName = `a`
        we push the <input data-variable="a" > element in the array
        that holds all elements which share this same `a` variable
        undefined assignment are ignored, instead use empty string*/

        if (!variableName) {
            console.error(
                element,
                `Use ${options.directives.variable}="variableName" format!`
            );
        }

        element[ELEMENT_PROPERTY] = options.propertyFromElement(element);
        const path = contextFromArrayWith(pathIn, variableName);
        pushOrCreateArrayAt(variableSubscribers, path, element);
        const lastValue = variables[path]; // has latest
        if (lastValue !== undefined) {
            notifyOneVariableSubscriber(element, lastValue);
        }

        if (options.tagNamesForUserInput.includes(element.tagName)) {
            const broadcastValue = function (event) {
                //wil call setter to broadcast the value
                const value = event.target[event.target[ELEMENT_PROPERTY]];
                variables[path] = value;
                // would notify everything including itself
                // notifyVariableSubscribers(variableSubscribers[path], value);
                variableSubscribers[path].forEach(function (variableSubscriber) {
                    if (variableSubscriber !== element) {
                        notifyOneVariableSubscriber(variableSubscriber, value);
                    }
                });
            };
            addEventListener(
                element,
                options.eventNameFromElement(element),
                broadcastValue
            );
        }
    };

    const applyDirectiveElement = function (element, attributeValue) {
        /* stores element for direct access !*/
        const elementName = attributeValue;

        if (!elementName) {
            console.error(
                element,
                `Use ${options.directives.element}="elementName" format!`
            );
        }
        const path = contextFromArrayWith(pathIn, elementName);
        elements[path] = element;
    };

    const applytemplate = function (element, attributeValue) {
        /* stores a template element for later reuse !*/
        if (!attributeValue) {
            console.error(
                element,
                `Use ${options.directives.template}="d-name" format!`
            );
        }

        templateFromName[attributeValue] = element;
    };

    activateCloneTemplate = function (template, key) {
        /* clones a template and activates it
        */
        enterObject(key);
        const activatedClone = cloneTemplate(template);
        activate(activatedClone);
        leaveObject();
        return activatedClone;
    };

    const applyInside = function (element, key) {
        /* looks for an html template to render
        also calls applyDirectiveElement with key!*/
        if (!key) {
            console.error(
                element,
                `Use ${options.directives.inside}="insidewhat" format!`
            );
        }

        const template = templateFromName[
            customElementNameFromElement(element)
        ];

        if (template) {
            const activatedClone = activateCloneTemplate(template, key);
            element.appendChild(activatedClone);
        } else {
             // avoid infinite loop
            element.setAttribute(
                options.directives.inside,
                options.doneSymbol + key
            );
             // parse children under name space (encapsulation of variable names)
            enterObject(key);
            activate(element);
            leaveObject();
        }
    };

    const deleteTemplate = function (name) {
        /* Removes a template */
        if (!hasOwnProperty.call(templateFromName, name)) {
            console.error(
                `<template ${options.directives.template}=${name}>
                </template> not found or already deleted and removed.`
            );
        }
        templateFromName[name].remove();
        delete templateFromName[name];
    };

    const tryApplyDirectives = function (element) {
        /* looks if the element has dom99 specific attributes and tries to handle it*/
        // todo make sure no impact-full read write
        if (!element.hasAttribute) {
            // can this if be removed eventually ? --> no
            return;
        }

        // spellsheck atributes
        const directives = Object.values(options.directives);
        const asArray = Array.prototype.slice.call(element.attributes);
        asArray.forEach(function (attribute) {
            if (attribute.nodeName.startsWith(`data`)) {
                if (directives.includes(attribute.nodeName)) {
                    
                } else {
                    console.warn(`dom99 does not recognize ${attribute.nodeName}`);
                }
            }
        });

        directivePairs.forEach(function ([directiveName, applyDirective]) {
            if (!element.hasAttribute(directiveName)) {
                return;
            }
            const attributeValue = element.getAttribute(directiveName);
            if (attributeValue[0] === options.doneSymbol) {
                return;
            }
            applyDirective(element, attributeValue);
            // ensure the directive is only applied once
            element.setAttribute(
                directiveName,
                options.doneSymbol + attributeValue
            );
        });
        if (
            element.hasAttribute(options.directives.inside) ||
            element.hasAttribute(options.directives.list)
        ) {
            return;
        }
        /*using a custom element without data-inside*/
        let customName = customElementNameFromElement(element);
        if (hasOwnProperty.call(templateFromName, customName)) {
            element.appendChild(
                cloneTemplate(templateFromName[customName])
            );
        }
    };

    activate = function (startElement = document.body) {
        //build array only once and use up to date options, they should not reset twice
        if (!directivePairs) {
            directivePairs = [
                /*order is relevant applyVariable being before applyFunction,
                we can use the just changed live variable in the bind function*/
                [options.directives.element, applyDirectiveElement],
                [options.directives.variable, applyVariable],
                [options.directives.function, applyFunctions],
                [options.directives.list, applylist],
                [options.directives.inside, applyInside],
                [options.directives.template, applytemplate]
            ];
        }
        elementsDeepForEach(startElement, tryApplyDirectives);
        return startElement;
    };

    const start = function (
        userFunctions = {},
        initialFeed = {},
        startElement = document.body,
        callBack = undefined
    ) {

        Object.assign(functions, userFunctions);
        feed(initialFeed);
        activate(startElement);
        if (!callBack) {
            return;
        }
        return callBack();
    };

    const plugin = function (featureToPlugIn) {

        if (hasOwnProperty.call(featureToPlugIn, `directives`)) {
            if (hasOwnProperty.call(featureToPlugIn.directives, `function`)) {
                pluggedFunctions.push(featureToPlugIn.directives.function);
                applyFunction = function (element, eventName, functionName) {
                    let defaultPrevented = false;
                    const preventDefault = function () {
                        defaultPrevented = true;
                    };
                    pluggedFunctions.forEach(function (pluginFunction) {
                        pluginFunction(element, eventName, functionName, functions, preventDefault);
                    });
                    if (defaultPrevented) {
                        return;
                    }
                    applyFunctionOriginal(element, eventName, functionName);
                };
            }
        }
    };

    // https://github.com/piecioshka/test-freeze-vs-seal-vs-preventExtensions
    return Object.freeze({
        start,
        activate,
        elements,
        functions,
        variables,
        feed,
        createElement2,
        forgetContext,
        deleteTemplate,
        contextFromArray,
        contextFromEvent,
        getParentContext,
        options,
        plugin
    });
}());

const MESSAGES={EXIT:"exit",LOADING_USER_LIST:"loading_user_list",SEND_ICE_CANDIDATE:"send_ice_candidate",RECEIVE_ICE_CANDIDATE:"receive_ice_candidate",SEND_OFFER:"send_offer",SEND_DESCRIPTION:"send_description",RECEIVE_DESCRIPTION:"receive_description",RECEIVE_OFFER:"receive_offer",LOCAL_SERVER_STATE:"LOCAL_SERVER_STATE",WELCOME:"welcome",SERVERLOG:"SERVERLOG",ID_CHANGE_REQUEST:"10",BAD_ID_FORMAT_REJECTED:"200",ALREADY_TAKEN_REJECTED:"201",CONFIRM_ID_CHANGE:"11",USER_ID_CHANGE:"12",CONDITION_ACCEPTED:"A"};

//yesNoDialog.js
/*jslint
    es6, maxerr: 15, browser, devel, fudge, maxlen: 100
*/
/*global
    Promise, require
*/
/*
could remove and give back focus to the main document with document.activeElement
as in https://github.com/GoogleChrome/dialog-polyfill/blob/master/dialog-polyfill.js
*/
const thisNameSpace = `yesNoDialog`;
const cssPrefix = `yes-no-dialog`;
const cssDialogActiveClass = `${cssPrefix}-active`;
const yesButton = d$1.contextFromArray([thisNameSpace, `yesButton`]);
const yesNoContainer = d$1.contextFromArray([thisNameSpace, `confirm`]);
const promptContainer = d$1.contextFromArray([thisNameSpace, `prompt`]);
const promptInput = d$1.contextFromArray([thisNameSpace, `input`]);
const yesNoSymbol = 0;
const promptSymbol = 1;

const yesNoDialogQueue = [];
let currentResolve;
let waiting = false;
let lastXPosition = 0;
let lastYPosition = 0;

const cleanUp = function () {
    waiting = false;
    document.body.classList.remove(cssDialogActiveClass);
    d$1.feed(thisNameSpace, {
        question: ``,
        label: ``,
        input: ``,
        submitText: ``,
        yesText: ``,
        noText: ``,
    });
    window.scrollTo(lastXPosition, lastYPosition);
};

const start = function () {
    lastXPosition = window.pageXOffset;
    lastYPosition = window.pageYOffset;
    document.body.classList.add(cssDialogActiveClass);
    waiting = true;
};

const prepareNext = function () {
    if (yesNoDialogQueue.length === 0) {
        cleanUp();
    } else {
        const next = yesNoDialogQueue.shift();
        if (next.intent !== promptSymbol) {
            d$1.elements[promptInput].blur();
        }
        if (next.intent === yesNoSymbol) {
            prepareYesNo(next);
        } else if (next.intent === promptSymbol) {
            preparePrompt(next);
        }
    }
};

const prepareYesNo = function ({resolve, question, yesText, noText}) {
    d$1.elements[yesNoContainer].hidden = false;
    currentResolve = resolve;
    d$1.feed(thisNameSpace, {
        question,
        yesText,
        noText
    });
};

const preparePrompt = function ({resolve, question, label, input, submitText}) {
    d$1.elements[promptContainer].hidden = false;
    currentResolve = resolve;
    d$1.feed(thisNameSpace, {
        question,
        label,
        input,
        submitText
    });
    d$1.elements[promptInput].focus();
};

d$1.functions.yesNoDialogAnswer = function (event) {
    d$1.elements[yesNoContainer].hidden = true;
    prepareNext();
    currentResolve(event.target === d$1.elements[yesButton]);
};

d$1.functions.yesNoDialogSubmit = function (event) {
    const input = d$1.variables[promptInput];
    // prepareNext can overwrite d.variables[promptInput]
    d$1.elements[promptContainer].hidden = true;
    prepareNext();
    currentResolve(input);
};

d$1.functions.yesNoDialogSubmitViaEnter = function (event) {
    if (event.keyCode === 13) { //Enter
        d$1.functions.yesNoDialogSubmit();
    }
};

const yesNoDialog = function (question, yesText, noText) {
    return new Promise(function (resolve) {
        if (!waiting) {
            start();
            prepareYesNo({resolve, question, yesText, noText});
        } else /*if (waiting)*/ {
            yesNoDialogQueue.push({
                intent: yesNoSymbol,
                question,
                yesText,
                noText,
                resolve
            });
        }
    });
};

const state={notificationEnabled:!1,localDisplayedName:"",isOnLine:!0,selectedUserId:"",lastSelectedUserId:"",uiIdStringLastSelected:"",files:[]};window.state=state;

const keyFromObjectAndValue=function(a,b){let c;return Object.entries(a).some(function([a,d]){if(d===b)return c=a, !0}), c};class OutOfOrderError extends Error{}

const bytes=function(){const a={standalone:0,begin:1,part:2,endpart:3},b=1,c=function(a,b,c){new Uint8Array(b).set(new Uint8Array(a),c);},d=function(d,e="standalone"){const f=d.byteLength,g=new ArrayBuffer(f+b);c(d,g,b);const h=new Uint8Array(g);return h[0]=a[e], g};return{headerBodyObjectFromArrayBuffer:function(a){var b=String.fromCharCode;const c=Uint8Array.BYTES_PER_ELEMENT;let d=0,e=!0,f="",g="";for(const c=new Uint8Array(a);e;)f+=g, g=b(c[d]), d+=1, e=!isNaN(+g);d-=1;const h=+f,i=a.slice(d*c,(d+h)*c),j=a.slice((d+h)*c),k=new Uint8Array(i),l=[];k.forEach(function(a){l.push(b(a));});const m=l.join("");let n;try{n=JSON.parse(m);}catch(a){console.log(a), a instanceof SyntaxError&&(console.log(`invalid JSON string: ${m} END of JSON string`), n={});}return{header:n,body:j}},arrayBufferFromHeaderBodyObject:function(a){const b=Uint8Array.BYTES_PER_ELEMENT,{header:d,body:e}=a,f=JSON.stringify(d),g=f.length,h=g+"",i=h.length,j=e.byteLength,k=new ArrayBuffer(b*i+b*g+j);let l=0;const m=new Uint8Array(k);return h.split("").forEach(function(a){m[l]=a.charCodeAt(0), l+=1;}), f.split("").forEach(function(a){m[l]=a.charCodeAt(0), l+=1;}), c(e,k,l*b), k},arrayBufferPromiseFromBlob:function(a){return new Promise(function(b,c){const d=new FileReader;d.onload=function(){b(d.result);}, d.onerror=function(a){c(a);}, d.readAsArrayBuffer(a);})},stringPromiseFromBlob:function(a){return new Promise(function(b,c){const d=new FileReader;d.onload=function(){b(d.result);}, d.onerror=function(a){c(a);}, d.readAsText(a);})},stringFromArrayBuffer:function(a,b="utf-8"){return new TextDecoder(b).decode(new DataView(a))},addInternalMessagePrefixToArrayBuffer:d,internalMessagePrefixFromArrayBuffer:function(b){const c=new Uint8Array(b);return keyFromObjectAndValue(a,c[0])},removeInternalMessagePrefixFromArrayBuffer:function(a){return a.slice(b)},splitArrayBuffer:function(a,b){const c=[],e=Math.ceil(a.byteLength/b);for(let f,g=0;g<e;)f=a.slice(g*b,(g+1)*b), f=0==g?d(f,"begin"):g+1<e?d(f,"part"):d(f,"endpart"), c.push(f), g+=1;return c},assembleArrayBuffer:function(a){let b=!1;if("begin"!==a[0][0]&&(b=!0), "endpart"!==a[a.length-1][0]&&(b=!0), b)throw new OutOfOrderError("splitData is in the wrong order");const d=a.reduce(function(a,[b,c]){return a+c.byteLength},0),e=new ArrayBuffer(d);let f=0;return a.forEach(function([a,b]){const d=b.byteLength;c(b,e,f), f+=d;}), e}}}();

const uiFiles=function(){const a="FI",b={CANNOT_LOAD_ZIP:"Could not load zip: ",FILE_LOADED:"file loaded"},c={tagName:"input",type:"file","data-function":"xReadFileStart",multiple:"multiple"},e=function(a){return a.map(function(a){return a.name}).reduce(function(a,b,c){const d=b.split("/");if(1<d.length){const b=d[0]+"/";if(b===a||0===c)return b}return""},"")},f=function(a,b){if(!b)return;const c=b.length;a.forEach(function(a){a.name=a.name.substr(c);});},g=function(a,b){let c,g,h=0,i=[];d$1.elements.fileProgress.hidden=!1, d$1.elements.fileProgress.max=b, d$1.elements.fileProgress.value=0;const j=function(){if(h<b)return void(d$1.elements.fileProgress.value=h);d$1.elements.fileProgress.hidden=!0, i=i.filter(function(a){return 0!==a.arrayBuffer.byteLength}), f(i,e(i));const j={files:i};c&&(j.package={packageString:g,packageObject:c}), a.readFileResolve(j), a.remove();};return{add:function(a,b,c){i.push({arrayBuffer:a,mime:b,name:c}), h+=1, j();},addPackage:function(a,b){g=a, c=b, h+=1, j();}}},h=function(a,b,c,d){j(d)?bytes.stringPromiseFromBlob(b).then(function(b){let c;try{c=JSON.parse(b);}catch(a){c={};}a.addPackage(b,c);}):bytes.arrayBufferPromiseFromBlob(b).then(function(b){a.add(b,c,d);});},i=function(a){if(4>a.length)return!1;const b=a.split(".");return b[1]&&"zip"===b[1]},j=function(a){return a.includes("package.json")},k=function(){return new Promise(function(a,b){const e=d$1.createElement2(c);e.readFileResolve=a, e.readFileReject=b, d$1.activate(e), d$1.elements.readFilesContainer.appendChild(e), e.click();})},l=function(a){return new Promise(function(b,c){zip.createReader(new zip.BlobReader(a),function(a){a.getEntries(b);},c);})},m=function(){return state.files.map(function(a){return a.name})},n=function(a){const b=state.files.find(function(b){return b.name===a});return void 0===b?void 0:{header:{"Content-Type":b[`mime`]},body:b[`body`]}},o=function(a){const b=a.filter(function(a){return"index.html"!==a}).map(function(a){return`<li><a href="${encodeURI(a)}">${a}</a></li>`}).join(""),c=`<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Index</title>
  </head>
  <body>
  <h1><a href="">Index</a></h1>
  <ul>
  ${b}
  </ul>
  </body>
</html>`;return c},p={"":"text/html",html:"text/html",css:"text/css",js:"application/javascript",json:"application/json"};return{ressourceFromRessourceName:n,start:function(){d$1.functions.xReadFileStart=function(a){const c=a.target.files;let d,e=g(a.target,c.length);for(d of c){const c=d.type||"",f=d.name;if(i(f))return void l(d).then(function(b){e=g(a.target,b.length), b.forEach(function(a){a.getData(new zip.BlobWriter,function(b){h(e,b,"",a.filename);});});}).catch(function(a){console.log(b.CANNOT_LOAD_ZIP+a,a);});h(e,d,c,f);}}, d$1.functions.removeRessource=function(a){const b=d$1.contextFromEvent(a),c=state.files.find(function(a){return a.uiLink===b});yesNoDialog(`Remove "${c.name}" ressource ?`,"Yes","No, Cancel").then(function(a){a&&(d$1.elements[d$1.contextFromArray([b,"baseEl"])].remove(), d$1.forgetContext(b), state.files.splice(state.files.indexOf(c),1));});}, d$1.functions.rememberFileName=function(a){const b=d$1.contextFromEvent(a),c=state.files.find(function(a){return a.uiLink===b});c.name=d$1.variables[d$1.contextFromArray([b,`fileName`])];}, d$1.functions.rememberFileBody=function(a){const b=d$1.contextFromEvent(a),c=state.files.find(function(a){return a.uiLink===b});c.body=d$1.variables[d$1.contextFromArray([b,`fileBody`])];}, d$1.functions.rememberMime=function(a){const b=d$1.contextFromEvent(a),c=state.files.find(function(a){return a.uiLink===b});c.mime=d$1.variables[d$1.contextFromArray([b,`fileMime`])];};let c=0;d$1.functions.addRessource=function(){k().then(function(e){const f=state.files,g=[];e.files.forEach(function(e){const{arrayBuffer:h,mime:i,name:j}=e,k=f.find(function(a){return a.name===j});if(k)return void g.push(yesNoDialog(`A ressource named "${j}" is already loaded. Overwrite old ressource with the new one ?`,"Yes, overwrite","No, keep old").then(function(a){if(!0===a){const a=k.uiLink;d$1.elements[d$1.contextFromArray([a,`fileBody`])].disabled=!0, d$1.feed(a,{fileBody:b.FILE_LOADED,fileMime:i}), k.body=h;}else if(!1===a);}));const l=a+(c+"");c+=1;const m=d$1.createElement2({tagName:"file-input","data-inside":l});d$1.feed(l,{fileName:j,fileBody:b.FILE_LOADED,fileMime:i}), d$1.activate(m), d$1.elements[d$1.contextFromArray([l,`fileBody`])].disabled=!0, state.files.push({name:j,body:h,mime:i,uiLink:l}), d$1.elements.ressourcesContainer.appendChild(m);}), Promise.all(g).then(function(){if(e.package&&e.package.packageObject.serverinthebrowser){const a=e.package.packageObject.serverinthebrowser;console.log("serverinthebrowser field detected",a);const b=a.server;if(b){const a=n(b).body;if(a){const b=bytes.stringFromArrayBuffer(a);d$1.feed(`userCode`,b);}}}});}).catch(function(a){d$1.feed(`log`,"Could not load file: "+a);});}, d$1.functions.addRessourceEmpty=function(){const b=a+(c+"");c+=1;const e=d$1.createElement2({tagName:"file-input","data-inside":b});d$1.feed(b,{fileName:"",fileBody:"",fileMime:""}), d$1.activate(e), d$1.elements.ressourcesContainer.appendChild(e);}, d$1.functions.generateIndex=function(){const b="index.html",e="text/html",f=m(),g=o(f),h=state.files.find(function(a){return a.name===b});if(h)return void yesNoDialog(`"${b}" already exists. Overwrite it ?`,"Yes","No, Cancel").then(function(a){if(a){const a=h.uiLink;d$1.elements[d$1.contextFromArray([a,"fileBody"])].disabled=!1, d$1.feed(a,{fileBody:g,fileMime:e}), h.body=g, h.mime=e;}});const i=a+(c+"");c+=1;const j=d$1.createElement2({tagName:"file-input","data-inside":i});d$1.feed(i,{fileName:b,fileBody:g,fileMime:e}), d$1.activate(j), d$1.elements.ressourcesContainer.appendChild(j), state.files.push({name:b,body:g,mime:e,uiLink:i});};},contentTypeFromRessourceName:function(a){const b=a.split("."),c=b[b.length-1];return p[c.toLowerCase()]||"octet/stream"}}}();

const sockets=function(){const a={socket:void 0};return Object.assign(a,{start:function(){a.socket=io();const b=a.socket;b.on(MESSAGES.WELCOME,(a)=>{state.localDisplayedName=a.displayedName, ui$1.displayOwnUserId(state.localDisplayedName), rtc.connectedUsers=a.connectedUsers, ui$1.updateUserList(a.connectedUsers);}), b.on(MESSAGES.LOADING_USER_LIST,function(a){rtc.connectedUsers=a.connectedUsers, ui$1.updateUserList(a.connectedUsers);}), b.on(MESSAGES.RECEIVE_DESCRIPTION,(a)=>{rtc.onReceiveRtcConnectionDescription(a);}), b.on(MESSAGES.RECEIVE_ICE_CANDIDATE,(a)=>{rtc.onReceiveRtcIceCandidate(a);}), b.on(MESSAGES.SERVERLOG,(a)=>{ui$1.serverLog(a);}), b.on(MESSAGES.BAD_ID_FORMAT_REJECTED,()=>{ui$1.handleChangeIdResponse(MESSAGES.BAD_ID_FORMAT_REJECTED);}), b.on(MESSAGES.ALREADY_TAKEN_REJECTED,()=>{ui$1.handleChangeIdResponse(MESSAGES.ALREADY_TAKEN_REJECTED);}), b.on(MESSAGES.CONFIRM_ID_CHANGE,(a)=>{ui$1.handleChangeIdResponse(MESSAGES.CONFIRM_ID_CHANGE,a);}), b.on(MESSAGES.USER_ID_CHANGE,(a)=>{ui$1.handleChangeIdResponse(MESSAGES.USER_ID_CHANGE,a);});},requestIdChange:function(b){a.socket.emit(MESSAGES.ID_CHANGE_REQUEST,{newId:b});}}), a}();

const browserServer=function(){const a={DISABLED:0,RUNNING:1},b={START:"START",CLOSE:"CLOSE",COMMAND:"COMMAND",URLSTART:"URLSTART",URLSTARTVALUE:location+""},c=1e3;let d,e,f=a.DISABLED,g="";const h=140;let i=1;const j={},k=function(){d&&(d.terminate(), d=void 0);};return{setBrowserServerCode:function(a){g=`/*node_emulator_for_worker.js
*/
/*jslint
es6, maxerr: 100, browser, devel, fudge, maxlen: 120, white: true, node, eval
*/
/*global
URL, Blob, Worker, self, importScripts
*/
"use strict";
/*need to manually escape some template strings*/
let module;
let exports;
let require;
let listenForRequest;
let respondToRequest;
let readStaticFile;
let process;
let __dirname;
//let _emptyFunction = function () {};
let _customFunction;
//let cleanUp;
(function () {
/*store local reference*/
const postMessage = self.postMessage;
const addEventListener = self.addEventListener;


const listeners = [];
const staticFilesResolves = {};
const COMMANDS = {
START: "START",
CLOSE: "CLOSE",
COMMAND: "COMMAND",
URLSTART: "URLSTART"
};

let state = 0;
let urlStart = "";

const tryCatchUserCode = function (tryFunction) {
try {
tryFunction();
} catch (error) {
let line;
if (error.lineNumber) {
line = Number(error.lineNumber) - ${h};
} else {
line = "?";
}
postMessage({"ERROR": {
line: line,
name: error.name,
message: error.message
}});
}
};

addEventListener("message", function(event) {
const message = event.data;
if (message[COMMANDS.COMMAND] === COMMANDS.START) {
state = 1;
urlStart = message[COMMANDS.URLSTART];
postMessage({"STARTSUCCES": "STARTSUCCES"});
tryCatchUserCode(_customFunction);
} else if (message[COMMANDS.COMMAND] === COMMANDS.CLOSE) {
state = 0;
self.close();
} else if (state) {

if (message.hasOwnProperty("headerBodyObject")) {
const headerBodyObject = message.headerBodyObject;//it s a copy
headerBodyObject.header.url = "/" + headerBodyObject.header.ressource;

tryCatchUserCode(function () {
listeners.forEach(function (listener) {

listener(headerBodyObject);
});
});
} else if (message.hasOwnProperty("staticFile")) {
const staticFileName = message.staticFile;
const body = message.body;
if (!staticFilesResolves.hasOwnProperty(staticFileName)) {
//why are we here? At this point we are not listening for the file body
return;
}
if (body === undefined) {
const errorMessage = message.error;
staticFilesResolves[staticFileName].reject.forEach(function (
rejectFunction) {
rejectFunction(errorMessage);
});

} else {
staticFilesResolves[staticFileName].resolve.forEach(function (
resolveFunction) {
resolveFunction(message);
});
}
delete staticFilesResolves[staticFileName];
}
}
}, false);

//remove access for the rest
const removeAccess = function (anObject, propertyName) {
Object.defineProperty(anObject, propertyName, {
value: undefined,
writable: false,
configurable: false,
enumerable: false
});
};
const hiddenAccessList = ["postMessage", "addEventListener", "onmessage", "close"];
hiddenAccessList.forEach(function (propertyName) {
removeAccess(self, propertyName);
});



/*cleanUp = function () {
;
};*/


(function () {
/* emulates nodes let module, exports, require
what should happen with exports = x ?
maybe change Object.defineProperty(self,"exports",
 setter: use single value= true, and store ... low prio
todo make overwriting the global module and export immpossible ?
limitation everything is public by default
it means that to port code from node you have to put everything in an IFFE and use module.export ... for the things to export
 */
const exportsObject = {};
const moduleObject = {};
const EXPORT = "exports";

let currentExportObject;// = {};
let currentExportSingleValue;// = undefined
let currentModuleObject;// = {};
let currentExportSingleValueUsed;// = false;

const exportsTraps = {
get: function (target, name) {
/*return the current local exports*/
return currentExportObject[name];
},
set: function (target, name, value) {
currentExportObject[name] = value;
}
};

const moduleTraps = {
/*todo add more traps*/
get: function (target, name) {
/*return the current local exports*/
if (name === EXPORT) {
if (currentExportSingleValueUsed) {
return currentExportSingleValue;
}
return exports;
}
return currentModuleObject[name];
},
set: function (target, name, value) {
currentModuleObject[name] = value;
if (name === EXPORT) {
currentExportSingleValue = value;
currentExportSingleValueUsed = true;
}
}
};

exports = new Proxy(exportsObject, exportsTraps);

module = new Proxy(moduleObject, moduleTraps);
const requireCache = {};
require = function(requiredName) {
if (requireCache.hasOwnProperty(requiredName)) {
/*if something is required twice do not execute the code again*/
return requireCache[requiredName];
}
currentExportObject = {};
currentExportSingleValue = undefined;
currentModuleObject = {};
currentExportSingleValueUsed = false;

const requiredUrl = urlStart + requiredName;
importScripts(requiredUrl); //downloads and execute

let returnValue; 
if (currentExportSingleValueUsed) {
returnValue = currentExportSingleValue;
} else {
returnValue = currentExportObject;
}
requireCache[requiredName] = returnValue;
return returnValue;
};


}());
process = {
env: {}
};

__dirname = "";

listenForRequest = function (afunction) {
listeners.push(afunction);
};

respondToRequest = function (headerBodyObject) {
//console.log("the worker is responding to a request with", headerBodyObject);
postMessage({headerBodyObject});
};

readStaticFile = function (staticFileName) {
/*reads a static file from the main thread
returns a promise that resolves with an Object
{staticFile: staticFileName,
body: *the body*,
"Content-Type": "string"}
or 
(reject)
{staticFile: staticFileName,
body: undefined,
error: errorString}
*/
return new Promise(function (resolve, reject) {
const stillWaiting = staticFilesResolves[staticFileName];
if (stillWaiting) {
/*already listeners*/
staticFilesResolves[staticFileName].resolve.push(resolve);
staticFilesResolves[staticFileName].reject.push(reject);
} else {
staticFilesResolves[staticFileName] = {};
staticFilesResolves[staticFileName].resolve = [resolve];
staticFilesResolves[staticFileName].reject= [reject];
}
postMessage({staticFile: staticFileName});
});
};

/*could still access hiddenAccessList with trow catch error.trace.object*/
//self = undefined;//cannot assign to self
}());

//have access to self [object DedicatedWorkerGlobalScope]
//const self = self;
const window = self; // to emulate
const global = self;
//cleanUp();
_customFunction = function () {
/*variables:require, listenForRequest, respondToRequest*/
${a};

};
`;},resultFromRequest:function(a){d&&d.postMessage(a);},answerObjectPromiseFromRequest:function(a){return new Promise(function(b,c){if(!d)return void c("No worker existing");const e=i+"";i+=1, j[e]=b, a.internalId=e, d.postMessage({headerBodyObject:a});})},run:function(){if(!g)return;k(), e&&window.clearTimeout(e);let i=!1;return new Promise(function(l,m){e=setTimeout(function(){i||(m(`Long startup time. More than ${c/1e3}s. This happens when an error is found.`), i=!0, e=void 0);},c);const n=new Blob([g],{type:"text/javascript"}),o=URL.createObjectURL(n);try{d=new Worker(o);}catch(a){k(), i=!0, m(`${a.name}: "${a.message}" at line ${+a.lineNumber-h}`);}d.addEventListener("error",function(a){k(), i=!0, m(`${a.message}`), a.stopPropagation(), a.preventDefault();},!1), URL.revokeObjectURL(o), d.addEventListener("message",function(a){const b=a.data;if(b.hasOwnProperty("STARTSUCCES"))l(), i=!0;else if(b.hasOwnProperty("headerBodyObject")){const a=b.headerBodyObject;if(a.hasOwnProperty("internalId")){const b=a.internalId;delete a.internalId, j.hasOwnProperty(b)&&(j[b](a), delete j[b]);}}else if(b.hasOwnProperty("staticFile")){const a=b.staticFile;let c=uiFiles.ressourceFromRessourceName(a),e={body:void 0,staticFile:a};c?(e.body=c.body, e["Content-Type"]=c.header["Content-Type"]||uiFiles.contentTypeFromRessourceName(a)):e.error="No file", d.postMessage(e);}else if(b.hasOwnProperty("ERROR")){const a=b.ERROR,c=`${a.name}: "${a.message}" at line ${a.line}`;k(), i?ui.lateReject(c):(m(c), i=!0);}},!1), d.postMessage({[b.COMMAND]:b.START,[b.URLSTART]:b.URLSTARTVALUE});})},close:k}}();

const rtc=function(){const a={};let b=!1;try{new AudioContext;}catch(a){}const c=798,e=new Map,f=new WeakMap,g=new WeakMap,h=new WeakMap,i={get:function(a){return h.get(e.get(a))},has:function(a){return h.has(e.get(a))},set:function(a,b){return h.set(e.get(a),b), b}},j={};let k=0;const l={iceServers:[{urls:"stun:stun.services.mozilla.com"},{urls:"stun:stun.l.google.com:19302"}]},m={ANSWER:"answer",REQUEST:"request",GET:"GET"},n=function(a){let b=a.header.ressource;""===b&&(b="index.html");let c=uiFiles.ressourceFromRessourceName(b);return c?{header:{"Content-Type":c.header["Content-Type"]||uiFiles.contentTypeFromRessourceName(b)},body:c.body}:{header:{"Content-Type":"text/html",status:404,statusText:"NOT FOUND"},body:`<html><p>Connection Successful ! But /${a.header.ressource} Not found (404)</p></html>`}},o=function(a,b,c=!1){if(!c&&a.bufferedAmount<a.bufferedAmountLowThreshold)return a.send(b), !1;else{const c=f.get(a);return c.push(b), !0}},p=function(a,b){if(!a||!x(a))return console.log(a), console.log(x(a)), console.log("if or"), console.log(!a), console.log(!x(a)), void ui$1.displayFatalError("The connection is not open or is it 1");const e=b.byteLength;if("string"==typeof b||e<c+10)return"string"!=typeof b&&(b=bytes.addInternalMessagePrefixToArrayBuffer(b)), void o(a,b);const f=bytes.splitArrayBuffer(b,c);let g=!1;f.forEach(function(b){g=o(a,b,g);});},q=function(a,b){let c="string"==typeof b.body?JSON.stringify(b):bytes.arrayBufferFromHeaderBodyObject(b);const e=i.get(a);p(e,c);},r=function(a){let b=function(){const c=i.get(a);if(c.bufferedAmount<c.bufferedAmountLowThreshold){const e=f.get(c);if(0===e.length)return;const g=e.shift();y(a)?(c.send(g), b()):ui$1.displayFatalError("The connection is not open 2 or is it ?");}};return b},s=function(a,c){let e,f,h=a.data||a;if("string"==typeof h)e=JSON.parse(h);else{if(h.size)return void bytes.arrayBufferPromiseFromBlob(h).then(function(a){s(a,c);}).catch(function(a){ui$1.displayFatalError("bytes.arrayBufferPromiseFromBlob"+a.toString(),a);});const a=bytes.internalMessagePrefixFromArrayBuffer(h);if(h=bytes.removeInternalMessagePrefixFromArrayBuffer(h), "standalone"!==a){const b=i.get(c),e=g.get(b);if(e.push([a,h]), "endpart"!==a)return;if("endpart"===a){g.set(b,[]);try{h=bytes.assembleArrayBuffer(e);}catch(a){if(a instanceof OutOfOrderError)w(), f=!0;else throw a}}}if(f)return;e=bytes.headerBodyObjectFromArrayBuffer(h);}if(e.header.is===m.REQUEST){const a=e.header.ressource;if("MESSAGE"===e.header.method)ui$1.handleMessage(e,c);else if(!d.variables.localServerAvailability);else{e.header.ressource=decodeURI(e.header.ressource);const f=function(b){b&&(b.header.is=m.ANSWER, b.header.ressource=a, q(c,b));};if(!b)f(n(e,c));else{const a=browserServer.answerObjectPromiseFromRequest(e,c);a.then(f).catch(function(a){console.log(a);});}}}else if(e.header.is===m.ANSWER){const a=e.header.ressource;j.hasOwnProperty(a)&&(j[a](e), delete j[a]);}},t=function(a,b){if(!e.has(b))return;const c=e.get(b);c.setLocalDescription(a).then(function(){sockets.socket.emit(MESSAGES.SEND_DESCRIPTION,{sdp:c.localDescription,displayedName:state.localDisplayedName,from:state.localDisplayedName,targetDisplayedName:b});}).catch(function(a){console.log("An error occured",a);});},u=function(a,b){let c,h;if(!e.has(b)){try{c=new RTCPeerConnection(l);}catch(a){if(console.log(a), a instanceof DOMException&&"InvalidStateError"===a.name)c=null, ui$1.markUserAsConnected(b,!1), ui$1.displayFatalError("Network is down, reconnect to the internet and try again.");else throw a}if(!c)return;c.onicecandidate=function(a){a.candidate&&sockets.socket.emit(MESSAGES.SEND_ICE_CANDIDATE,{ice:a.candidate,from:state.localDisplayedName,targetDisplayedName:b});}, h=c.createDataChannel("app",{ordered:!0,maxPacketLifeTime:3e3}), h.bufferedAmountLowThreshold=2e3, h.binaryType="arraybuffer", f.set(h,[]), g.set(h,[]), h.onbufferedamountlow=r(b);const a=v(b);h.onopen=a, h.onclose=a, c.ondatachannel=function(a){const c=a.channel;c.onmessage=function(a){s(a,b);};}, h.onmessage=function(a){console.log("Receive data from rtcSendDataChannel",a.data);}, e.set(b,c), i.set(b,h);}else c=e.get(b);a&&c.createOffer().then(function(a){t(a,b);}).catch(function(a){console.log("An error occured",a);});},v=function(a){return()=>{ui$1.markUserAsConnected(a,y(a)), ui$1.selectAfterConnected(a);}},w=function(){return k+=1, console.log("resendAllRtcRequests:",k), console.log("BUG, this function is only called if the parts arrive out of order:"), 10<k?(console.log("resendAllRtcRequests too high, canceling and resetting count",k), void(k=0)):void Object.keys(j).forEach(function(a){q(j[a].target,j[a].message);})},x=function(a){return"open"===a.readyState},y=function(a){return x(i.get(a))};return Object.assign(a,{useHandleRequestCustom:function(a){b=a;},sendRtcMessage:function(a,b){q(a,{header:{is:m.REQUEST,method:"MESSAGE","Content-Type":"text/plain"},body:b});},startConnectionWith:u,rtcRequest:function(a){return new Promise(function(b){const c=a.header.ressource;j[c]=b;const e={header:{is:m.REQUEST,method:a.header.method||m.GET,"Content-Type":"",ressource:c},body:a.body||""};j[c].message=e, j[c].target=state.selectedUserId, q(state.selectedUserId,e);})},onReceiveRtcConnectionDescription:function(a){e.has(a.from)||u(!1,a.from);const b=e.get(a.from);b&&b.setRemoteDescription(new RTCSessionDescription(a.sdp)).then(function(){"offer"===a.sdp.type&&b.createAnswer().then((b)=>{t(b,a.from);}).catch(function(a){console.log("An error occured",a);});}).catch(function(a){console.log("An error occured",a);});},onReceiveRtcIceCandidate:function(a){if(a.from!==state.localDisplayedName){let b=e.get(a.from);b&&b.addIceCandidate(new RTCIceCandidate(a.ice)).then(function(){}).catch(function(a){console.log("An error occured",a);});}},rtcPeerConnectionFromId:e,isOpenFromDisplayName:y,userIdChange:function(a,b){if(e.has(a)){const c=i.get(a),f=v(b);c.onopen=f, c.onclose=f, e.set(b,e.get(a)), e.delete(a);}}}), a}();

const localData=function(){const a=function(a){let c;try{c=JSON.parse(localStorage.getItem(a));}catch(a){try{b();}catch(a){}c=void 0;}return c},b=function(){localStorage.clear();};return{get:a,getElseDefault:function(b,c){const d=a(b);return null===d?c:d},set:function(a,b){return localStorage.setItem(a,JSON.stringify(b))},clearAll:b}}();

const serviceWorkerSupport=window.navigator&&window.navigator.serviceWorker&&window.navigator.serviceWorker.register;const serviceWorkerManager=function(){const a=function(){return!!serviceWorkerSupport&&(navigator.serviceWorker.register("/service_worker").then(function(a){}).catch(function(a){console.error("service worker could not install:",a);}), navigator.serviceWorker.addEventListener("message",function(a){const b=a.data;if(b.hasOwnProperty("LOG"))return void ui$1.serverLog(b.LOG);const c=b,d=c.header.ressource;rtc.rtcRequest(c).then(function(a){navigator.serviceWorker.controller.postMessage({ressource:d,answer:a});});}), navigator.serviceWorker.addEventListener("activate",function(){console.log("serviceWorker: activate",location.origin);}), navigator.serviceWorker.addEventListener("controllerchange",function(){console.log("serviceWorker: controllerchange");}), !0)};return{start:function(){a()||ui$1.displayFatalError("Service worker must be enabled");},deleteServiceWorker:function(){serviceWorkerSupport&&(navigator.serviceWorker.getRegistrations?navigator.serviceWorker.getRegistrations().then(function(a){for(let b of a)b.unregister().then(function(a){console.log("serviceWorker: unregistered",a);});}):navigator.serviceWorker.getRegistration&&navigator.serviceWorker.getRegistration().then(function(a){a&&a.unregister().then(function(a){console.log("serviceWorker: unregistered",a);});}));}}}();

window.d=d$1;const ui$1=function(){const a={CONNECTING:"Connecting",CONNECTED:"Connected",SELECT:"Select",SELECTED:"Selected",CONNECT_SELECT:"Connect and select",BAD_ID_FORMAT:"The ID didn't match the following requirement. An ID is 4 to 25 characters long, and only etters from a to Z and digits from 0 to 9  are allowed.",ALREADY_TAKEN_REJECTED:"The ID is already taken. Chose another ID.",ID_CHANGE_REQUEST_SENT:"The request to change the ID has been sent. Waiting for an answer.",ID_CHANGE_SUCCESS:"Your ID has been successfully changed."},b=function(a){return!a||"keydown"!==a.type||13===a.keyCode&&!a.shiftKey};let c=function(){},e="",f=[];const g={},h=function(b){const c="user_"+b;b&&(d$1.elements[`${c}>connectButton`].disabled=!0, d$1.feed(`${c}>connectButton`,a.CONNECTING), g[b]=1);},i=function(b,c=!0){const e="user_"+b;b&&(d$1.elements[`${e}>connectButton`].disabled=c, d$1.elements[`${e}>selectButton`].disabled=!c, d$1.elements[`${e}>selectButton`].hidden=!c, c?(d$1.feed(e,{connectButton:a.CONNECTED,selectButton:a.SELECT}), g[b]=2):(d$1.elements[`${e}>connectButton`].disabled=!1, d$1.elements[`${e}>selectButton`].disabled=!0, d$1.elements[`${e}>selectButton`].hidden=!0, d$1.feed(e,{connectButton:a.CONNECT_SELECT}), g[b]=0));},j=function(b,c=!0){if(2!==g[b]&&(c=!1), l(b), state.uiIdStringLastSelected="user_"+state.selectedUserId, state.lastSelectedUserId=state.selectedUserId, state.lastSelectedUserId&&c&&(d$1.elements[`${state.uiIdStringLastSelected}>selectButton`].disabled=!1, d$1.feed(`${state.uiIdStringLastSelected}>selectButton`,a.SELECT), d$1.elements[state.uiIdStringLastSelected+"host"].className=""), c){state.selectedUserId=b;const c="user_"+state.selectedUserId;d$1.elements[`${c}>selectButton`].disabled=!0, d$1.feed(`${c}>selectButton`,a.SELECTED), d$1.elements[c+"host"].className="active";}else{state.selectedUserId="";const c="user_"+b;d$1.elements[`${c}>selectButton`].disabled=!1, d$1.feed(`${c}>selectButton`,a.SELECT), d$1.elements[c+"host"].className="";}},k=function(b){const c=b.map(function(a){return a.displayedName}).filter((a)=>a!==state.localDisplayedName);d$1.elements.connected_users.innerHTML="", f.forEach(function(a){d$1.forgetContext(a);}), f=[], c.map(function(b){const c="user_"+b;f.push(c);const e=d$1.createElement2({tagName:"li",is:"user-item","data-inside":c,"data-element":c+"host"});d$1.feed(d$1.contextFromArray([c,"userDisplayName"]),b), d$1.activate(e), rtc.rtcPeerConnectionFromId.has(b)&&rtc.isOpenFromDisplayName(b)&&(d$1.elements[c+"host"].className="", d$1.feed(`${c}>connectButton`,a.CONNECTED), d$1.elements[`${c}>connectButton`].disabled=!0, d$1.elements[`${c}>selectButton`].disabled=!1, d$1.elements[`${c}>selectButton`].hidden=!1), 1===g[b]&&h(b), 2===g[b]&&i(b), d$1.elements.connected_users.appendChild(e);}), Object.keys(g).forEach(function(a){c.includes(a)||delete g[a];}), state.selectedUserId&&j(state.selectedUserId);},l=function(a){const b=rtc.isOpenFromDisplayName(a),c=rtc.connectedUsers.some(function(b){return b.displayedName===a&&b.isServer}),e=!b;d$1.elements.send_button.disabled=e, d$1.elements.input.disabled=e, d$1.elements.indexLink.classList.toggle("disabled",!c);},m=function(a){n(!a), d$1.elements.main.hidden=!a;const b=localData.get("state.localDisplayedName");b&&(d$1.feed(`newId`,b), d$1.functions.idChangeRequest()), d$1.feed(`log`,"");},n=function(a=!0){return d$1.elements.landingPage.hidden=!a, d$1.feed(`log`,""), new Promise(function(a){c=a;})};let o=function(a){d$1.activate();let b=0;const c=function(a){return{innerHTML:`<a href="${a}" target="_blank" rel="noopener noreferrer">${a}</a>`}};Object.keys(a).forEach(function(e){b+=1;const f=`i${b}`,g=a[e],h=d$1.createElement2({tagName:"missing-feature","data-inside":f});d$1.feed(f,{title:e,text:g.text,links:g.links.map(c)}), d$1.activate(h), d$1.elements.missingFeatures.appendChild(h);});};const p=[],q=function(a){const b=document.createElement("p");b.textContent=d$1.variables.lastMessage, d$1.elements.allButLastMessages.appendChild(b), p.push(b), d$1.feed(`lastMessage`,a), p.length>50&&p.shift().remove();},r=function(a){d$1.elements.parsingResult.classList.toggle("error",!0), d$1.feed(`parsingResult`,a), d$1.feed(`useCustom`,!1), rtc.useHandleRequestCustom(!1);};return{start:function(){uiFiles.start(), d$1.functions.acceptAndStart=function(){c(), m(!0), localData.set(MESSAGES.CONDITION_ACCEPTED,"true");}, d$1.functions.changeCustom=function(){const a=d$1.variables.useCustom;a&&(d$1.feed(`useCustom`,!1), d$1.feed(`parsingResult`,"Stopped while editing !"), rtc.useHandleRequestCustom(!1), browserServer.close());}, d$1.functions.warnBeforeLeaveChange=function(){console.log(d$1.variables.warnBeforeLeave), localData.set("warnBeforeLeave",d$1.variables.warnBeforeLeave);}, d$1.functions.wantNotificationChange=function(){const a=d$1.variables.wantNotification;let b;a?"Notification"in window?"granted"===Notification.permission?(b="Notifications enabled", state.notificationEnabled=!0, localData.set("notifications",state.notificationEnabled)):(b="Waiting for autorization", d$1.feed(`wantNotification`,!1), Notification.requestPermission(function(a){"granted"===a?(state.notificationEnabled=!0, localData.set("notifications",state.notificationEnabled), d$1.feed(`wantNotificationFeedBack`,"Notifications enabled"), d$1.feed(`wantNotification`,state.notificationEnabled)):(d$1.feed(`wantNotificationFeedBack`,"Notifications access denied"), state.notificationEnabled=!1, localData.set("notifications",state.notificationEnabled));})):(b="This browser does not support desktop notification, or this option has been disabled", state.notificationEnabled=!1, localData.set("notifications",notificationEnabled), d$1.feed(`wantNotification`,notificationEnabled)):(b="Notifications disabled", state.notificationEnabled=!1, localData.set("notifications",state.notificationEnabled)), d$1.feed(`wantNotificationFeedBack`,b);}, d$1.functions.useCustom=function(){const a=d$1.variables.useCustom;a?(browserServer.setBrowserServerCode(d$1.variables.userCode), browserServer.run().then(function(){d$1.elements.parsingResult.classList.toggle("error",!1), d$1.feed(`parsingResult`,"Successfully parsed"), rtc.useHandleRequestCustom(!0);}).catch(r)):(browserServer.close(), rtc.useHandleRequestCustom(!1));}, d$1.functions.sendMessage=function(a){b(a)&&(rtc.sendRtcMessage(state.selectedUserId,d$1.variables.input), q(`You to ${state.selectedUserId}:  ${d$1.variables.input}`), d$1.feed(`input`,""), a.preventDefault());}, d$1.functions.connectToUser=function(a){const b=d$1.variables[d$1.contextFromArray([d$1.contextFromEvent(a),"userDisplayName"])];h(b), e=b, rtc.startConnectionWith(!0,b);}, d$1.functions.selectUser=function(a){const b=d$1.variables[d$1.contextFromArray([d$1.contextFromEvent(a),"userDisplayName"])];j(b);}, d$1.functions.debug=function(){const b=5;d$1.feed(`log`,b), console.log(b);}, d$1.functions.idChangeRequest=function(c){if(b(c)){const b=/[a-zA-Z0-9]{4,25}/,c=d$1.variables.newId,e=c.length;return b.test(c)?void(sockets.requestIdChange(c), d$1.feed(`idChangeFeedback`,a.ID_CHANGE_REQUEST_SENT), d$1.elements.idChangeRequestButton.disabled=!0, d$1.elements.newId.disabled=!0):void d$1.feed(`idChangeFeedback`,a.BAD_ID_FORMAT)}}, d$1.functions.changeLocalServerAvailability=function(){sockets.socket.emit(MESSAGES.LOCAL_SERVER_STATE,{displayedName:state.localDisplayedName,isServer:d$1.variables.localServerAvailability});}, d$1.functions.deleteAll=function(){yesNoDialog(`Delete all local data and quit ?`,"Yes","No, Cancel").then(function(a){a&&(localData.clearAll(), serviceWorkerManager.deleteServiceWorker(), d$1.feed(`warnBeforeLeave`,!1), caches.keys().then(function(a){return Promise.all(a.map(function(a){return caches.delete(a)}))}).then(function(){location.href+="quit";}));});};const f=function(a){d$1.elements[a].remove(), d$1.forgetContext(a);};o=void 0, d$1.feed({log:"Starting ...",input:"",output:"",newId:"",warnBeforeLeave:localData.getElseDefault("warnBeforeLeave",!1),wantNotification:localData.getElseDefault("notifications",state.notificationEnabled)}), d$1.functions.wantNotificationChange(), d$1.feed({useCustom:!1,your_id:"not yet connected",localServerAvailability:!1,userCode:`const http = require("http");
const hostname = "127.0.0.1";
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader("Content-Type", "text/plain");
  res.end("Hello World\\n");
});

server.listen(port, hostname, () => {
  console.log(\`Server running at http://\${hostname}:\${port}/\`);
});
    `}), d$1.activate(), f("missingFeatures"), f("missingFeatureTemplate");},updateUserList:k,displayOwnUserId:function(){d$1.feed(`your_id`,state.localDisplayedName);},displayFatalError:function(a,...b){d$1.feed(`log`,a), console.log(a), b&&0<b.length&&console.log(...b);},display:m,displayLandingPage:n,markUserAsConnected:i,markUserAsSelected:j,selectAfterConnected:function(a){e===a&&j(a);},serverLog:function(a){d$1.feed(`serverLog`,d$1.variables.serverLog+"\n"+JSON.stringify(a)), console.log(a);},handleMessage:function(a,b){q(`From ${b}:  ${a.body}`);},handleChangeIdResponse:function(b,c){if(b===MESSAGES.USER_ID_CHANGE||b===MESSAGES.CONFIRM_ID_CHANGE){const{newId:f,oldId:h}=c;if(rtc.connectedUsers.some(function(a){if(a.displayedName===h)return a.displayedName=f, !0}), b===MESSAGES.CONFIRM_ID_CHANGE)state.localDisplayedName=f, localData.set("state.localDisplayedName",f), d$1.feed({newId:"",your_id:f,idChangeFeedback:a.ID_CHANGE_SUCCESS});else if(b===MESSAGES.USER_ID_CHANGE)return e===h&&(e=f), state.selectedUserId===h&&(state.selectedUserId=f), g[h]&&(g[f]=g[h], delete g[h]), rtc.userIdChange(h,f), void k(rtc.connectedUsers)}else b===MESSAGES.BAD_ID_FORMAT_REJECTED?d$1.feed(`idChangeFeedback`,a.BAD_ID_FORMAT):b===MESSAGES.ALREADY_TAKEN_REJECTED&&d$1.feed(`idChangeFeedback`,a.ALREADY_TAKEN_REJECTED);d$1.elements.idChangeRequestButton.disabled=!1, d$1.elements.newId.disabled=!1;},displayNonMetRequirement:o,lateReject:r}}();

const MAX_NOTIFICATION_TIME=8e3; const launcher=function(){"http:"===location.protocol&&"http://localhost:8080/"!==location.href&&(location.href="https"+location.href.slice(4));const a=document.getElementById("starterror");if(a&&a.remove(), window.test=window.test||!1, !window.test){const a={"Service Worker":{API:navigator.serviceWorker,text:"Service Worker must be enabled. Service Worker cannot be used in private browsing mode.",links:["https://duckduckgo.com/?q=how+to+enable+service+worker"]},WebRTC:{API:window.RTCPeerConnection,text:"WebRTC must be enabled.",links:["https://duckduckgo.com/?q=how+to+enable+webrtc"]}},b=function(a){let b=!1;const c={};return Object.keys(a).forEach(function(d){a[d].API||(b=!0, c[d]=a[d]);}), !!b&&c}(a);if(b)return void ui$1.displayNonMetRequirement(b);ui$1.start();const c=function(){serviceWorkerManager.start(), sockets.start(), window.addEventListener("beforeunload",function(a){if(d$1.variables.warnBeforeLeave){const b="Are you sure you want to leave ?";return a.returnValue=b, b}},!1), window.addEventListener("unload",function(){sockets.socket.emit(MESSAGES.EXIT,{});},!1);const a=function(){if(!state.notificationEnabled)return;state.isOnLine=navigator.onLine;let a=state.isOnLine?"Connected to the network":"Not connected to the network";const b=new Notification("Online Status",{body:a,tag:"onLine",noscreen:!0});setTimeout(b.close.bind(b),MAX_NOTIFICATION_TIME);};window.addEventListener("online",a), window.addEventListener("offline",a);};c(), ui$1.display(!0);}};launcher();
